"use strict";(globalThis.webpackChunkts_playground_documentation=globalThis.webpackChunkts_playground_documentation||[]).push([[864],{2975:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"best-practices","title":"Best Practices","description":"Industry-standard best practices for TypeScript development. Advanced type manipulation, architectural patterns, and professional development guidelines.","source":"@site/docs/best-practices.md","sourceDirName":".","slug":"/best-practices","permalink":"/ts-playground/best-practices","draft":false,"unlisted":false,"editUrl":"https://github.com/Kingson4Wu/ts-playground/edit/main/documentation/website/docs/best-practices.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Best Practices","description":"Industry-standard best practices for TypeScript development. Advanced type manipulation, architectural patterns, and professional development guidelines.","keywords":["typescript best practices","advanced patterns","architectural patterns","professional development","type manipulation"]},"sidebar":"docs","previous":{"title":"Code Quality Standards","permalink":"/ts-playground/standards"},"next":{"title":"Project Architecture & Structure","permalink":"/ts-playground/project-structure"}}');var s=t(4848),i=t(8453);const a={sidebar_position:3,title:"Best Practices",description:"Industry-standard best practices for TypeScript development. Advanced type manipulation, architectural patterns, and professional development guidelines.",keywords:["typescript best practices","advanced patterns","architectural patterns","professional development","type manipulation"]},o="Best Practices",c={},l=[{value:"TypeScript Advanced Best Practices",id:"typescript-advanced-best-practices",level:2},{value:"Advanced Type Manipulation",id:"advanced-type-manipulation",level:3},{value:"Discriminated Unions for Type Safety",id:"discriminated-unions-for-type-safety",level:3},{value:"Const Assertions for Immutable Data",id:"const-assertions-for-immutable-data",level:3},{value:"Architectural Best Practices",id:"architectural-best-practices",level:2},{value:"Layered Architecture Pattern",id:"layered-architecture-pattern",level:3},{value:"Dependency Injection Implementation",id:"dependency-injection-implementation",level:3},{value:"Configuration Management",id:"configuration-management",level:3},{value:"Performance &amp; Memory Management Best Practices",id:"performance--memory-management-best-practices",level:2},{value:"Efficient Data Structures",id:"efficient-data-structures",level:3},{value:"Async Operation Optimization",id:"async-operation-optimization",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Security Best Practices",id:"security-best-practices",level:2},{value:"Input Validation &amp; Sanitization",id:"input-validation--sanitization",level:3},{value:"Authentication &amp; Authorization",id:"authentication--authorization",level:3},{value:"Testing Best Practices",id:"testing-best-practices",level:2},{value:"Comprehensive Test Strategy",id:"comprehensive-test-strategy",level:3},{value:"Property-Based Testing Concepts",id:"property-based-testing-concepts",level:3},{value:"Production Readiness Best Practices",id:"production-readiness-best-practices",level:2},{value:"Observability &amp; Monitoring",id:"observability--monitoring",level:3},{value:"Health Checks &amp; Monitoring",id:"health-checks--monitoring",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"best-practices",children:"Best Practices"})}),"\n",(0,s.jsx)(n.p,{children:"This comprehensive guide outlines industry-standard best practices for TypeScript development within the ts-playground project, designed to align with professional backend development standards."}),"\n",(0,s.jsx)(n.h2,{id:"typescript-advanced-best-practices",children:"TypeScript Advanced Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"advanced-type-manipulation",children:"Advanced Type Manipulation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Conditional Types for Dynamic Behavior:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'type IsString<T> = T extends string ? true : false;\ntype StringStatus = IsString<"hello">; // true\n\n// Advanced utility for API response handling\ntype ApiResponse<T> = {\n  success: true;\n  data: T;\n} | {\n  success: false;\n  error: string;\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Generic Constraints with Multiple Bounds:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface Lengthwise {\n  length: number;\n}\n\nfunction getProperty<T extends object, K extends keyof T>(obj: T, key: K) {\n  return obj[key];\n}\n\nfunction logLength<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"discriminated-unions-for-type-safety",children:"Discriminated Unions for Type Safety"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface LoadingState {\n  status: 'loading';\n  progress?: number;\n}\n\ninterface SuccessState<T> {\n  status: 'success';\n  data: T;\n  timestamp: Date;\n}\n\ninterface ErrorState {\n  status: 'error';\n  error: Error;\n}\n\ntype ApiState<T> = LoadingState | SuccessState<T> | ErrorState;\n\nfunction handleApiState<T>(state: ApiState<T>) {\n  switch (state.status) {\n    case 'loading':\n      console.log(`Loading: ${state.progress || 0}%`);\n      break;\n    case 'success':\n      console.log(`Success at ${state.timestamp}`);\n      break;\n    case 'error':\n      console.error(state.error.message);\n      break;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"const-assertions-for-immutable-data",children:"Const Assertions for Immutable Data"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const API_CONFIG = {\n  endpoints: {\n    users: '/api/users',\n    posts: '/api/posts',\n  },\n  timeout: 5000,\n} as const;\n\n// Results in:\n// - API_CONFIG.endpoints.users being of type '/api/users' (not string)\n// - All properties becoming readonly\n"})}),"\n",(0,s.jsx)(n.h2,{id:"architectural-best-practices",children:"Architectural Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"layered-architecture-pattern",children:"Layered Architecture Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Domain Layer: Pure business logic\nclass UserDomain {\n  constructor(private readonly validationRules: ValidationRules) {}\n\n  async validate(user: Partial<User>): Promise<ValidationResult> {\n    return this.validationRules.validate(user);\n  }\n}\n\n// Application Layer: Orchestrates domain and infrastructure\nclass UserService {\n  constructor(\n    private readonly userDomain: UserDomain,\n    private readonly userRepository: UserRepository,\n    private readonly logger: Logger\n  ) {}\n\n  async createUser(userData: UserCreationRequest): Promise<User> {\n    try {\n      const validation = await this.userDomain.validate(userData);\n      if (!validation.isValid) throw new ValidationError(validation.errors);\n\n      const user = await this.userRepository.create(userData);\n      this.logger.info(`User created: ${user.id}`);\n      return user;\n    } catch (error) {\n      this.logger.error('User creation failed', error);\n      throw error;\n    }\n  }\n}\n\n// Infrastructure Layer: External integrations\ninterface UserRepository {\n  create(data: UserCreationRequest): Promise<User>;\n  findById(id: string): Promise<User | null>;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dependency-injection-implementation",children:"Dependency Injection Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Using a simple DI container or constructor injection\ninterface DependencyContainer {\n  resolve<T>(token: Token<T>): T;\n}\n\nclass UserService {\n  constructor(\n    private readonly container: DependencyContainer\n  ) {}\n\n  async processUser(userId: string): Promise<void> {\n    const userRepository = this.container.resolve<UserRepository>('userRepository');\n    const emailService = this.container.resolve<EmailService>('emailService');\n    const user = await userRepository.findById(userId);\n\n    if (user) {\n      await emailService.sendWelcomeEmail(user.email);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"configuration-management",children:"Configuration Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface AppConfig {\n  readonly database: {\n    readonly host: string;\n    readonly port: number;\n    readonly name: string;\n  };\n  readonly api: {\n    readonly port: number;\n    readonly cors: {\n      readonly origin: string[];\n    };\n  };\n}\n\nclass ConfigService {\n  private static instance: ConfigService;\n  private readonly config: AppConfig;\n\n  private constructor() {\n    this.config = {\n      database: {\n        host: process.env.DB_HOST || 'localhost',\n        port: parseInt(process.env.DB_PORT || '5432'),\n        name: process.env.DB_NAME || 'ts_playground',\n      },\n      api: {\n        port: parseInt(process.env.API_PORT || '3000'),\n        cors: {\n          origin: process.env.CORS_ORIGINS?.split(',') || ['http://localhost:3000'],\n        },\n      },\n    };\n  }\n\n  static getInstance(): ConfigService {\n    if (!ConfigService.instance) {\n      ConfigService.instance = new ConfigService();\n    }\n    return ConfigService.instance;\n  }\n\n  get<T extends keyof AppConfig>(key: T): AppConfig[T] {\n    return this.config[key];\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance--memory-management-best-practices",children:"Performance & Memory Management Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"efficient-data-structures",children:"Efficient Data Structures"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Use Maps for frequent lookups instead of array.find()\nconst userMap = new Map<string, User>();\nuserMap.set('user1', { id: 'user1', name: 'John' });\nconst user = userMap.get('user1'); // O(1) complexity\n\n// Use Sets for unique collections\nconst uniquePermissions = new Set<string>(['read', 'write', 'delete']);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"async-operation-optimization",children:"Async Operation Optimization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Concurrent execution when possible\nasync function fetchUserDataConcurrently(userId: string) {\n  const [profile, permissions, notifications] = await Promise.all([\n    profileService.getProfile(userId),\n    permissionService.getUserPermissions(userId),\n    notificationService.getUnreadCount(userId)\n  ]);\n\n  return { profile, permissions, notifications };\n}\n\n// Sequential execution when order matters\nasync function processUserRegistration(userData: UserRegistration) {\n  const validatedUser = await validationService.validate(userData);\n  const createdUser = await userRepository.create(validatedUser);\n  await emailService.sendWelcomeEmail(createdUser.email);\n  await analyticsService.trackEvent('user_registered', createdUser.id);\n\n  return createdUser;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Proper cleanup for event emitters and subscriptions\nclass ServiceWithCleanup {\n  private disposables: Array<() => void> = [];\n\n  async initialize() {\n    const subscription = eventBus.subscribe('user.created', this.handleUserCreated);\n    this.disposables.push(() => subscription.unsubscribe());\n\n    const timer = setInterval(() => this.cleanup(), 30000);\n    this.disposables.push(() => clearInterval(timer));\n  }\n\n  async cleanup() {\n    for (const dispose of this.disposables) {\n      try {\n        dispose();\n      } catch (error) {\n        logger.warn('Error during cleanup', error);\n      }\n    }\n    this.disposables = [];\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"input-validation--sanitization",children:"Input Validation & Sanitization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import validator from 'validator';\n\nclass InputValidator {\n  static validateEmail(email: string): ValidationResult {\n    if (!validator.isEmail(email)) {\n      return { isValid: false, error: 'Invalid email format' };\n    }\n    return { isValid: true };\n  }\n\n  static sanitizeString(input: string): string {\n    return validator.escape(validator.trim(input));\n  }\n\n  static validatePassword(password: string): ValidationResult {\n    if (password.length < 8) {\n      return { isValid: false, error: 'Password must be at least 8 characters' };\n    }\n    if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/.test(password)) {\n      return { isValid: false, error: 'Password must contain uppercase, lowercase, and number' };\n    }\n    return { isValid: true };\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"authentication--authorization",children:"Authentication & Authorization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface AuthenticatedRequest extends Request {\n  user: User;\n}\n\nconst authenticate = async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const token = req.header('Authorization')?.replace('Bearer ', '');\n    if (!token) {\n      throw new AuthenticationError('Access token required');\n    }\n\n    const decoded = jwt.verify(token, config.jwt.secret);\n    const user = await userService.findById(decoded.userId);\n    if (!user) throw new AuthenticationError('Invalid token');\n\n    (req as AuthenticatedRequest).user = user;\n    next();\n  } catch (error) {\n    res.status(401).json({ error: 'Authentication failed' });\n  }\n};\n\nconst requirePermission = (permission: string) =>\n  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\n    if (!req.user.permissions.includes(permission)) {\n      res.status(403).json({ error: 'Insufficient permissions' });\n      return;\n    }\n    next();\n  };\n"})}),"\n",(0,s.jsx)(n.h2,{id:"testing-best-practices",children:"Testing Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"comprehensive-test-strategy",children:"Comprehensive Test Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Integration test example\ndescribe('User Registration Integration', () => {\n  let app: Express;\n  let testServer: Server;\n\n  beforeAll(async () => {\n    app = createApp();\n    testServer = app.listen(0); // Random available port\n  });\n\n  afterAll(async () => {\n    await testServer.close();\n  });\n\n  beforeEach(async () => {\n    await cleanupTestDatabase(); // Clean state for each test\n  });\n\n  it('should register user and send welcome email', async () => {\n    // Arrange\n    const newUser = { email: 'test@example.com', name: 'Test User' };\n    const response = await request(app)\n      .post('/api/users/register')\n      .send(newUser);\n\n    // Assert\n    expect(response.status).toBe(201);\n    expect(response.body.email).toBe(newUser.email);\n\n    // Verify side effects\n    const user = await User.findOne({ email: newUser.email });\n    expect(user).toBeDefined();\n\n    // Verify email was sent (using email mock/stub)\n    expect(emailService.sendWelcomeEmail).toHaveBeenCalledWith(newUser.email);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"property-based-testing-concepts",children:"Property-Based Testing Concepts"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Using property-based testing for validation\nfunction testValidationProperty(input: string, expected: boolean) {\n  const result = InputValidator.validateEmail(input);\n  expect(result.isValid).toBe(expected);\n}\n\n// Test with various inputs to ensure robustness\nconst testCases = [\n  { input: 'valid@example.com', expected: true },\n  { input: 'invalid-email', expected: false },\n  { input: 'test@domain.co.uk', expected: true },\n  { input: '', expected: false },\n];\n\ntestCases.forEach(({ input, expected }) => {\n  test(`Email validation for: ${input}`, () => {\n    testValidationProperty(input, expected);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"production-readiness-best-practices",children:"Production Readiness Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"observability--monitoring",children:"Observability & Monitoring"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface Logger {\n  info(message: string, meta?: any): void;\n  error(message: string, error?: Error): void;\n  warn(message: string, meta?: any): void;\n  debug(message: string, meta?: any): void;\n}\n\nclass UserService {\n  constructor(private readonly logger: Logger) {}\n\n  async createUser(userData: UserCreationRequest): Promise<User> {\n    const startTime = Date.now();\n\n    try {\n      this.logger.info('Creating user', { email: userData.email });\n\n      const user = await this.userRepository.create(userData);\n\n      this.logger.info('User created successfully', {\n        userId: user.id,\n        duration: Date.now() - startTime\n      });\n\n      return user;\n    } catch (error) {\n      this.logger.error('User creation failed', error);\n      throw new UserServiceError('Failed to create user', error);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"health-checks--monitoring",children:"Health Checks & Monitoring"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface HealthIndicator {\n  isHealthy(): Promise<boolean>;\n  getDetails(): Promise<HealthDetails>;\n}\n\nclass DatabaseHealthIndicator implements HealthIndicator {\n  constructor(private readonly connection: DatabaseConnection) {}\n\n  async isHealthy(): Promise<boolean> {\n    try {\n      await this.connection.query('SELECT 1');\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  async getDetails(): Promise<HealthDetails> {\n    const startTime = Date.now();\n    const healthy = await this.isHealthy();\n    const responseTime = Date.now() - startTime;\n\n    return {\n      name: 'database',\n      status: healthy ? 'up' : 'down',\n      responseTime,\n      timestamp: new Date().toISOString(),\n    };\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"These professional best practices ensure that code developed in the ts-playground environment aligns with industry standards and prepares developers for real-world backend development challenges."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);